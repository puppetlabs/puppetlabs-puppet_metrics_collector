#!/opt/puppetlabs/puppet/bin/ruby

require_relative 'pe_metrics'

def get_status_endpoint(host, port, ssl)
  host_url = generate_host_url(host, port, ssl)

  status_endpoint = "#{host_url}/status/v1/services?level=debug"
  status_output   = get_endpoint(status_endpoint, ssl)
end

def individually_retrieve_additional_metrics(host, port, metrics, ssl)
  host_url = generate_host_url(host, port, ssl)

  metrics_array = []
  metrics.each do |metric|
    endpoint = URI.escape("#{host_url}/metrics/v1/mbeans/#{metric['url']}")
    metrics_array <<  { 'name' => metric['name'], 'data' => get_endpoint(endpoint, ssl) }
  end

  return metrics_array
end

def bulk_retrieve_additional_metrics(host, port, metrics, ssl)
  host_url = generate_host_url(host, port, ssl)

  post_data = []
  metrics.each do |metric|
    post_data << metric['url']
  end

  endpoint = "#{host_url}/metrics/v1/mbeans"
  metrics_output = post_endpoint(endpoint, post_data.to_json, ssl)
  metrics_array = []

  metrics.each_index do |index|
    metric_name = metrics[index]['name']
    metric_data = metrics_output[index]
    metrics_array << { 'name' => metric_name, 'data' => metric_data  }
  end

  return metrics_array
end

def retrieve_additional_metrics(host,port,metrics, pe_version, ssl)
  if Gem::Version.new(pe_version) < Gem::Version.new('2016.2.0') then
    metrics_array = individually_retrieve_additional_metrics(host, port, metrics, ssl)
  else
    metrics_array = bulk_retrieve_additional_metrics(host, port, metrics, ssl)
  end

  return metrics_array
end

output_file = Time.now.utc.strftime('%Y%m%dT%H%M%SZ') + '.json'

HOSTS.each do |host|
  begin
    timestamp = Time.now
    dataset = {'timestamp' => timestamp.utc.iso8601, 'servers' => {}}
    hostkey = host.gsub('.', '-')
    dataset['servers'][hostkey] = { METRICS_TYPE => {} }

    status_output = get_status_endpoint(host, PORT, SSL)

    dataset['servers'][hostkey][METRICS_TYPE] = status_output

    unless ADDITIONAL_METRICS.empty? then
      metrics_array = retrieve_additional_metrics(host, PORT, ADDITIONAL_METRICS, PE_VERSION, SSL)
      metrics_array.each do |metric_hash|
        metric_name = metric_hash['name']
        metric_data = metric_hash['data']
        dataset['servers'][hostkey][METRICS_TYPE][metric_name] = metric_data
      end
    end

    dataset['servers'][hostkey][METRICS_TYPE]['error'] = $error_array
    dataset['servers'][hostkey][METRICS_TYPE]['error_count'] = $error_array.count
    dataset['servers'][hostkey][METRICS_TYPE]['api-query-start'] = timestamp.utc.iso8601
    dataset['servers'][hostkey][METRICS_TYPE]['api-query-duration'] = Time.now - timestamp

    filtered_dataset = filter_metrics(dataset, EXCLUDES)
    json_dataset = JSON.generate(filtered_dataset)

    unless OUTPUT_DIR.nil? then
      Dir.chdir(OUTPUT_DIR) do
        Dir.mkdir(host) unless File.exist?(host)
        File.open(File.join(host, output_file), 'w') do |file|
          file.write(json_dataset)
        end
      end
    end
    if OPTIONS[:print] != false then
      # Use puts so that data gatherd from each host is written to stdout
      # with a newline separator. This enables parsing of multiple datasets
      # as the output stream is in line-delimited JSON form.
      STDOUT.puts(json_dataset)
    end
  end
end
